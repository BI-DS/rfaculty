
## Modulo and integer division

Recall that when $n,k\in\mathbb{Z}$ are integers, there is a unique number $0\leq r< |k|$ so that $n/k = q + r/k$. Here $q\in\mathbb{Z}$ is the quotient and $r$ the remainder.

### Example
* $13/4 = 12/4 + 1/4 = 3 + 1/4$, 
* Hence $3$ is the quotient when $13$ is divided by $4$.
* And $1$ is the remainder

### In `R`

```{r}
print(13 %/% 4)
print(13 %% 4)
```

:::{.panel-tabset}

### Exercise
Write a program that checks if `7` is odd. (Hint: What is the remainder when you divide an odd number by 2?)

### Solution
```{r}
7 %% 2 == 1
```

:::


## Floating point numbers

Decimal numbers are stored in a *floating point* format on the form 
$$-1^S\cdot M \cdot 2^E,$$

where $M$ is the *mantissa*, $E$ is the exponent, and $S$ is the sign. 

The mantissa is stored using 52 bits. 

Let $x=123$, for instance. This means that $x=1\cdot10^2 + 2\cdot 10^1 + 3\cdot 10^0$.

What is $1/123$ in decimals? 

It's $0.00813008130081300813\ldots$, with $0081300$ repeating infinitely many times.

We first see this with $1/3=0.3333333\ldots$. 

In other words, it's **impossible** to store $1/3$ with infinite precision as a decimal number. Only numbers $x = k / (2^n5^m)$ have a finite decimal expansion. (Where $k,n,m$ are integers.) 

But computers do not use decimal numbers, they use binary numbers. Here only numbers on the $x= k / 2^m$ form have a finite decimal expansion.

| Decimal | $x = k / (2^n5^m)$  | $x= k / 2^m$     |
| ------- | -----------------   | ---------------- |
| 0.2     | $2/(2 \cdot 5)$     | None!            |
| 0.5     | $1/2$               | $1/2$            |
| 0.1     | $1/(2 \cdot 5)$     | None!            |
| 0.03    | $3/(2^2 \cdot 5^2)$ | None!            |

Equalities like these will be true when all numbers have have precise binary expansions. 
```{r}
0.5 + 1.5 == 2
```


#### Exercise
> Predict what will happen when

## Floating points are very, very tricky

* **Never use the equal sign to compare floating point numbers.**
* Calculated results *will not* be infinitely precise.
* The double floating points use $64$ bits to represent a number. This translates to a precision of $\approx 1.11 \cdot 10^{-16}$ decimal places.
* But the numbers are one the form $(-1)^S\cdotM\cdot2^E$, where $M$ (the mantissa) contains information about significant digits and $E$ is the exponent.
* Details are *not important*, and even specialists struggle with floating points.

### Exercise

```{r}
x = 10000
y = 1e4
```


### The `NULL` type

The `NULL` type is a strange type that *sort of* represents an empty list.

```{r}
c()
```

```{r}
NULL
```

```{r}
c(NULL, NULL)
```

Concatenation with `NULL`:

```{r}
c(1, NULL, 2)
```

```{r}
c()
```

```{r}
list()
```

```{r}
typeof(list())
```



### Empty vectors

```{r}
seq(from=0, to=10)[0]
```

```{r}
c(0.1, pi, exp(1))[0]
```

```{r}
"Victor Norman"[0]
```


```{r}
print(NULL)
print(list())
```

```{r}
print(typeof(NULL))
print(typeof(list()))
```

```{r}
print(length(NULL))
print(length(list()))
```

### Exercise

> Make 

```{r}
list(list(), list(), list())
```



# Vectors

A *vector* is an ordered sequence of elements. It's **not** a mathematical vector!

There are two kinds of vectors:

1. *Atomic vectors* contain elements of the same type,
2. Lists contain elements of potentially different type.

### Atomic vectors

The most important are:

1. Numeric types: `double` (real number), also `integer` and `complex`,
2. Logical,
3. Strings (or `character`).

Construct vectors using `c` (concatenate):

```{r}
x <- c(1,2,3)
x
typeof(x)
```

The type of `x` is `double`, just as a single number. In fact, `R` treats numbers as vectors of one element!
```{r}
typeof(x)
```

```{r}
length(x)
```

```{r}
length(1)
```

## Boolean (logical) vectors
Logical vectors are constructed in the same way -- these are more important than you'd expect!
```{r}
logicals <- c(TRUE, FALSE, FALSE)
```

Atomic vector elements must be of the same type. Types are often *casted*:
```{r}
stuff <- c(55, FALSE, "foo")
stuff
```

```{r}
typeof(stuff)
```

Here `character` is the "broadest" type, hence the elements are casted to it.

But that is not always possible. 
```{r}
stuff <- c(55, FALSE, "foo", sum)
```

Now `stuff` is of type `"list"`, which may contain elements of arbitrary type.

```{r}
typeof(stuff)
```




### Solution

### Exercise
Make a function that calculates the sum of all multiples of `n` below `m`.

```{r}
#| eval: False
sum_mul(2, 9)    # 2 + 4 + 6 + 8 = 20
sum_mul(3, 13)   # 3 + 6 + 9 + 12 = 30
sum_mul(4, 123)  # 4 + 8 + 12 + ... = 1860
```

### Solution

```{r}
sum_mul <- \(n, m) sum(seq(0,m-1,by=n))
sum_mul(2, 9)    # 2 + 4 + 6 + 8 = 20
sum_mul(3, 13)   # 3 + 6 + 9 + 12 = 30
sum_mul(4, 123)  # 4 + 8 + 12 + ... = 1860
```


